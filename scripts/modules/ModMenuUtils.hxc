import funkin.modding.PolymodHandler;
import funkin.modding.module.Module;
import funkin.save.Save;
import funkin.util.ReflectUtil;
import funkin.util.VersionUtil;

import flixel.graphics.FlxGraphic;

import haxe.ds.StringMap;

import openfl.display.BitmapData;
import openfl.utils.ByteArrayData;

// IMPORTS FOR ASSET RELOADING
import funkin.data.dialogue.conversation.ConversationRegistry;
import funkin.data.dialogue.dialoguebox.DialogueBoxRegistry;
import funkin.data.dialogue.speaker.SpeakerRegistry;
import funkin.data.event.SongEventRegistry;
import funkin.data.story.level.LevelRegistry;
import funkin.data.notestyle.NoteStyleRegistry;
import funkin.play.notes.notekind.NoteKindManager;
import funkin.data.song.SongRegistry;
import funkin.data.freeplay.player.PlayerRegistry;
import funkin.data.stage.StageRegistry;
import funkin.play.character.CharacterDataParser;
import funkin.data.freeplay.album.AlbumRegistry;
import funkin.modding.module.ModuleHandler;

class ModMenuUtils extends Module
{
    var modMenuID = "Funkin' Mod Menu";

    final defaultModSave = {
        enabled: true,
        favorited: false,
        lastVersion: null
    };

    final SAVE_KEY = "funkin-mod-menu";

    function getSaveData()
    {
        // Access/Modify save data in a safe way

        var modSave = Save.instance.modOptions;
        var save = modSave.get(SAVE_KEY);

        if (save == null)
        {
            trace("Funkin' Mod Menu Save Data Not Found; Creating New Save.");
            save = new StringMap();
            modSave.set(SAVE_KEY, save);
        }

        return save;
    }

    function getModData(mod:ModMetadata)
    {
        // Access/Modify mod data in a safe way

        var save = getSaveData();
        var modData = save.get(mod.id);

        if(modData == null)
        {
            // Creates new saved data
            modData = ReflectUtil.copy(defaultModSave);
            modData.lastVersion = mod.modVersion;
            save.set(mod.id, modData);
        }

        return modData;
    }

    public function new()
    {
        super('ModMenuUtils');

        trace("Mod Menu Utils Initialized.");

        for(mod in PolymodHandler.getAllMods())
        {
            if(mod.title == modMenuID)
            {
                modMenuID = mod.id;
                break;
            }
        }

        trace("Funkin' Mod Menu Save Data Found: " + getSaveData());
    }

    public function getModIcon(mod:ModMetadata)
    {
        if(mod == null || mod.icon == null)
            return Paths.image("modmenu/no_icon");

        return (FlxGraphic.fromBitmapData(BitmapData.fromBytes(ByteArrayData.fromBytes(mod.icon)), false));
    }

    public function toggleMod(mod:ModMetadata)
    {
        var modData = getModData(mod);
        modData.enabled = !modData.enabled;
        trace("Mod Toggle Status Updated; " + modData.enabled);
    }

    public function isModEnabled(mod:ModMetadata)
    {
        return getModData(mod).enabled;
    }

    public function toggleFavorite(mod:ModMetadata)
    {
        var modData = getModData(mod);
        modData.favorited = !modData.favorited;
        trace("Mod Favorited Status Updated; " + modData.favorited);
    }

    public function isModFavorited(mod:ModMetadata)
    {
        return getModData(mod).favorited;
    }

    public function isModNew(mod:ModMetadata)
    {
        return !getSaveData().exists(mod.id);
    }

    public function isModMissingDependencies(mod:ModMetadata)
    {
        if(mod.dependencies == null) return false;
        var missingDependencies = [];
        for(dependency in mod.dependencies.keys())
        {
            if(PolymodHandler.getAllModIds().contains(dependency))
            {
                if(!VersionUtil.validateVersion(PolymodHandler.getAllMods()[PolymodHandler.getAllModIds().indexOf(dependency)].modVersion, mod.dependencies.get(dependency)))
                {
                    missingDependencies.push(dependency);
                }
            }
            else
            {
                missingDependencies.push(dependency);
            }
        }
        if(missingDependencies.length > 0)
        {
            return true;
        }
        return false;
    }

    public function loadEnabledMods() // NOTE: NO LONGER ABLE TO 100% REPLICATE RELOAD FUNCTIONALITY. POLYMOD CLASS IS BLACKLISTED.
    {
        var modsToLoad = [];

        for(mod in PolymodHandler.getAllMods())
        {
            var modData = getModData(mod); // getModData saves new data for the mod if no mod data exists
            modData.lastVersion = mod.modVersion;

            if(isModEnabled(mod))
                modsToLoad.push(mod.id);
        }

        if(modsToLoad.length > 0)
        {
            if (!modsToLoad.contains(modMenuID)) // Ensures Mod Menu loads itself in case of a save bug
                modsToLoad.insert(0, modMenuID);

            trace("Loading Mods: " + modsToLoad.join(", "));
            PolymodHandler.loadModsById(modsToLoad);
        }
        else
        {
            trace("No Mods Enabled, Loading All Mods.");
            PolymodHandler.loadAllMods();
        }

        ModuleHandler.clearModuleCache();

        // Polymod.clearScripts();
        // Polymod.registerAllScriptClasses();

        SongEventRegistry.loadEventCache();

        SongRegistry.instance.loadEntries();
        LevelRegistry.instance.loadEntries();
        NoteStyleRegistry.instance.loadEntries();
        PlayerRegistry.instance.loadEntries();
        ConversationRegistry.instance.loadEntries();
        DialogueBoxRegistry.instance.loadEntries();
        SpeakerRegistry.instance.loadEntries();
        AlbumRegistry.instance.loadEntries();
        StageRegistry.instance.loadEntries();

        CharacterDataParser.loadCharacterCache();
        NoteKindManager.loadScripts();
        ModuleHandler.loadModuleCache();

        trace("Mod Loading Completed.");
    }
}
